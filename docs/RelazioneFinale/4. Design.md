# Documento 4 - Design

## Indice:
### 1. Introduzione
### 2. Modelling
#### 2.1 Approccio alla modellazione
#### 2.2 Diagrammi UML utilizzati
### 3. Software Architecture
#### 3.1 Descrizione dell'architettura
#### 3.2 Viste architetturali
#### 3.3 Componenti e connettori
#### 3.4 Librerie esterne
### 4. Software Design Pattern
#### 4.1 Pattern adottati
#### 4.2 Benefici del design adottato
### 5. Conclusioni

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 1. Introduzione

Questo documento descrive le scelte di design adottate per il sistema sviluppato, facendo riferimento a quali diagrammi UML e quali pattern di progettazioni abbiamo utilizzato.

L'obiettivo è dare una visione completa delle decisioni che abbiamo preso che hanno fatto da guida per l'implementazione del sistema.
Questo ci ha permesso di aumentare la coerenza con i requisiti definiti e con l'approccio di sviluppo che abbiamo usato per progettare.

## 2. Modelling
### 2.1 Approccio alla modellazione

La modellazione del sistema è stata realizzata attraverso i diagrammi UML, con le modalità definite nel corso. 
Abbiamo usato i diagrammi UML per supportarci nella progettazione, consentendo di descrivere in modo chiaro struttura statica e comportamento dinamico del sistema.

Tutti i diagrammi sono disponibili per la consultazione in formato SVG nella cartella [exported_diagrams](../exported_diagrams).
Siccome Papyrus mandava in crash il sistema quasi tutti i diagrammi sono stati realizzati in PlantUML, tranne il diagramma delle classi dal quale abbiamo estratto il codice con un tool.
Tutti gli script che abbiamo utilizzato per generare i diagrammi sono disponibili per la consultazione nella cartella [diagrams](../../diagrams).

La scelta di separare documentazione e diagrammi è utile per rendere più ordinato il progetto.

### 2.2 Diagrammi UML utilizzati

Nel progetto abbiamo utilizzato tutti i diagrammi che abbiamo trattato durante il corso:

**Diagramma dei casi d'uso:** 
Serve per rappresentare le interazioni tra gli attori e le funzionalità del sistema. Questo diagramma ci ha aiutato a capire le funzionalità del sistema.

**Diagramma delle classi:**
Descrive la struttura statica del sistema, dal quale abbiamo ricavato il codice Java per l'implementazione.

**Diagrammi di sequenza:**
Modellano il flusso delle interazioni tra gli oggetti nei casi d'suo più importanti, evidenziando come e in che ordine vengono scambiati i messaggi.

**Diagrammi di attività:**
Rappresentano i flussi di lavoro del sistema, in particolare, nel nostro caso, la gestione dell'iscrizione alla gara.

**Diagrammi di stato:**
Descrivono il ciclo di vita di alcune entità rilevanti come quello di una gara di pesca che può trovarsi in diversi stati durante lo svolgimento di essa.

**Diagrammi di comunicazione e temporali:**
Rappresentano rispettivamente le modalità di interazione tra i componenti del sistema e i vincoli temporali associati a determinate sequenze di eventi.

**Diagramma dei componenti:**
Divide il sistema in componenti software ed evidenzia le dipendenze tra di essi.

**Diagrammi dei package:**
Viene aggiornato per completare la descrizione dell'organizzazione logica del sistema che è suddiviso in moduli che sono collegati tra loro.

## 3. Software Architecture
### 3.1 Descrizione dell'architettura

L'architettura del sistema ha seguito uno sviluppo modulare, per separare le responsabilità e aiutare nella manutenibilità futura del codice.
Per questo motivo il software è formato da componenti che riflettono le principali aree funzionali che abbiamo individuato nella stesura dell'analisi dei requisiti.

Abbiamo separato le seguenti unità di lavoro:
* logica di dominio;
* gestione dei dati;
* gestione delle interazioni con gli utenti.

### 3.2 Viste architetturali

Abbiamo deciso di adottare due viste architetturali diverse per poter analizzare più punti di vista differenti, che ci ha aiutato a migliorare la comprensione delle scelte architetturali effettuate.

* **Vista logica:** evidenzia i componenti software e le loro responsabilità;
* **Vista strutturale:** mostra l'organizzazione dei moduli e le dipendenze tra essi.

### 3.3 Componenti e connettori

I componenti software comunicano tra loro tramite interfacce definite.

I connettori fanno interagire i componenti e permettono di scambiare i dati e la coordinazione delle operazioni.

Abbiamo adottato uno stile architetturale che ha favorito la modularità riducendo l'accoppiamento tra le parti del sistema.
Questo ha migliorato la manutenibilità e la possibilità di estensione.

### 3.4 Librerie esterne

Per sviluppare il progetto abbiamo utilizzato delle librerie esterne gestite tramite il Maven, per fornire supporto alle funzionalità non implementate direttamente dal team.
L'utilizzo di queste librerie ha migliorato affidabilità e qualità del sistema.

## 4. Software Design Pattern
### 4.1 Pattern adottati

I design pattern rappresentano soluzioni generali a problemi ricorrenti di progettazione. 
Vanno usati con cautela perchè non sono delle soluzioni per ogni cosa, quindi potrebbero complicare la struttura del software.

Nel nostro progetto abbiamo applicato i pattern valutando la loro utilità effettiva.

**Abstraction-Occurrence:** 
L'abbiamo utilizzato per separare i concetti astratti del dominio dalle loro istanze concrete. 
Nel nostro esempio abbiamo evitato la duplicazione del codice distinguendo tra la definizione astratta di una gara e le singole prove che si svolgono nel tempo.

**Player-Role:**
Garantisce all'utente di potersi iscrivere come qualsiasi attore contenuto nel diagramma dei casi d'uso.
Questo ha migliorato l'incapsulamento e rende il sistema più flessibile.

**Singleton:**
Evita le duplicazioni garantendo l'esistenza di una sola istanza di alcune classi di servizio centrali.

**Delegation:**
Migliora la modularità del codice lasciando specifiche responsabilità a oggetti dedicati.

**Façade:**
Fornisce un'interfaccia semplificata verso sottosistemi interni più complessi. 
Questo ha ridotto l'accoppiamento e ha migliorato la leggibilità del sistema.

### 4.2 Benefici del design adottato

Adottando i design pattern abbiamo migliorato l'organizzazione del codice, riducendo la duplicazione delle informazioni.
Questo faciliterà la manutenzione futura.

## 5. Conclusioni

Il design del sistema è ottenuto integrando requisiti, modellazione UML e scelte architetturali.
L'utilizzo dei diagrammi ha fornito una base per l'implementazione del software, perchè sono in grado di schematizzare la realtà da implementare per renderla più facile da capire.