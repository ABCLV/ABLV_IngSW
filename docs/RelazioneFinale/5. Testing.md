# Documento 5 - Testing

## Indice:
### 1. Introduzione
### 2. Strategia di testing
### 3. Test di unità
#### 3.1 Obiettivi dei test di unità
#### 3.2 Alcuni casi di test implementati
### 4. Copertura dei test
### 5. Conclusioni

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 1. Introduzione

Questo documento espone tutte le scelte che abbiamo adottato per svolgere le attività di testing nel progetto,
con l'obiettivo di verificare la correttezza delle funzionalità e aumentare la qualità complessiva del software.

## 2. Strategia di testing

La fase di testing è avvenuta in parallelo all'implementazione, seguendo un approccio incrementale.

Abbiamo deciso di soffermarci in particolare sulla verifica della logica di dominio, che rappresenta il fulcro del sistema oltre che essere soggetta al maggior numero di errori logici.

Per questo motivo, le attività di test si sono concentrate sulle classi del [package model](../../ABLV_IngSW/src/test/java/model), che includono le entità del sistema e le regole che si occupano di gestire la gara, i concorrenti e le classifiche.

I test sono automatici perché implementati come test di unità JUnit, eseguibili direttamente dall’ambiente di sviluppo senza intervento manuale.

## 3. Test di unità
### 3.1 Obiettivi dei test di unità

I test sono stati eseguiti con l'obiettivo di:

* verificare il corretto comportamento delle classi implementate;
* validare le regole di business del sistema;
* scovare errori logici nel codice;
* ridurre il rischio di regressioni durante l'evoluzione del codice.

### 3.2 Alcuni casi di test implementati

Alcuni tra i casi di test di unità implementati nel modello di dominio sono:

* GaraTest e CampionatoTest: verificano la gestione delle competizioni;
* ConcorrenteTest, SocietaTest e SponsorTest: gestiscono correttamente le entità coinvolte;
* TurnoTest, SettoreTest e CampoGaraTest: validano la struttura delle gare;
* PunteggioTest: valuta la corretta assegnazione dei punteggi
* AmministrazioneTest e ArbitroTest: gestiscono ruoli e operazioni consentite.

Ogni test serve a verificare che lo stato degli oggetti e dei risultati corrisponda al comportamento atteso.

## 4. Copertura dei test

I test coprono le classi del modello di dominio, che rappresenta la parte funzionale del sistema e questo indica che è anche la più significativa.

I test di unità coprono le principali entità e le regole del sistema; 
questo si riflette nella riduzione dei rischi di errori logici e di regressioni durante lo sviluppo.

Abbiamo concordato che il livello di copertura ottenuto, considerando i limiti temporali dovuti soprattutto agli esami che ogni componente del team ha dovuto affrontare,
sia adeguato per migliorare la qualità del progetto e coerente con il contesto universitario.

## 5. Conclusioni

Le attività di testing hanno contribuito a migliorare l'affidabilità del sistema e a individuare errori nelle fasi iniziali del progetto.

Abbiamo preferito l'utilizzo di test automatizzati per facilitare il controllo della qualità del software e per eventuali aggiornamenti nel futuro.